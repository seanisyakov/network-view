<!DOCTYPE html>

<meta charset="utf-8">
<style>

.node {
  stroke: #bbb;
  stroke-width: 0.5px;
}

.link {
  stroke: #999;
  stroke-opacity:0.5;
  stroke-width: 1.5px;
}


circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}


</style>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>D3 Test</title>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src = "tester.js"></script>
    </head>
    <body>
    <script>


// initializes the objects 


// the links represent each of clip submission (comparison)logically we represent those as links
//
var links = b.cameras;

//if false do something
var keyc = true, keys = true, keyt = true, keyr = true, keyx = true, keyd = true, keyl = true, keym = true, keyh = true, key1 = true, key2 = true, key3 = true, key0 = true

//waits for a node to be hovered over
var focus_node = null, highlight_node = null;

//colour of relationship being observed
var highlight_color = "blue";
var highlight_trans = 0.1;

//paramaters to scale the zoom function
var min_zoom = 0.1;
var max_zoom = 7;

var zoom = d3.behavior.zoom().scaleExtent([min_zoom,max_zoom])

  
var size = d3.scale.pow().exponent(1)
  .domain([1,100])
  .range([8,24]);


//initializes all the nodes

// takes the cameras that formed links and creates unique nodes
function stripLinks(links) {
  var nodes = {};
  links.forEach(function(link) {
  link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
  link.target = nodes[link.target] || (nodes[link.target] = {name: link.target}) 
});
  return nodes
}

nodes = stripLinks(links)
console.log(nodes);

var width = 960,
    height = 500;

var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    .linkDistance(100)
    .charge(-300)
    .on("tick", tick)
    .start();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var link = svg.selectAll(".link")
    .data(force.links())
    .enter().append("line")
    .attr("class", "link");

var node = svg.selectAll(".node")
    .data(force.nodes())
    .enter().append("g")
    .attr("class", "node")
    .on("mouseover", mouseover)
    .on("mouseout", mouseout)
    .call(force.drag);

node.append("circle")
    .attr("r", 8);

node.append("text")
    .attr("x", 12)
    .attr("dy", ".35em")
    .text(function(d) { return d.name;});


// clips refer to a data point in the tester.js file. Every clip refers to a comparison (two products and how they fair: source and target)


function isInArray(value, array) {
  return array.indexOf(value) > -1;
}


// We used a map to strip down the data to just the distinct nodes that appear. When it comes to the display, we don't want to produce multiple nodes for each camera.


function createMap() {
  connectionMap = new Map()
  for (var i = 0; i < links.length; i++){
  var clip = links[i];
  //goes through all of the clips and adds every new unique camera to 
  if (!(connectionMap.has(clip["target"]))){
    var firstSource = new Set();
    connectionMap.set(clip["target"], firstSource.add(clip["source"]));
    }else{
      //if the product is already in the set then we still have to add the source to the list of things its compared to. multiples are taken care of with the set.
      var updatedValues = connectionMap.get(clip["target"]);
      updatedValues.add(clip["source"]);
      connectionMap.set(connectionMap["target"], updatedValues);
 }
  if (!(connectionMap.has(clip["source"]))){
  var firstTarget = new Set();
  connectionMap.set(clip["source"], firstTarget.add(clip["target"]));
  }else{  
    var updatedValues = connectionMap.get(clip["source"]);
      updatedValues.add(clip["target"]);
      connectionMap.set(connectionMap["source"], updatedValues);

  
 }
  
}

return connectionMap

}

var distinctNodes = createMap()



// returns a list of all nodes that only had one connection

function findLoners(nodeMap) {  
  var loners = [];
  for (var [key, value] of nodeMap){
  if(value.size == 1){
      loners.push(key);
  }
}
return loners
}

var listOfLoners = findLoners(distinctNodes)



 


var links2 = links.slice();
var collapse = new Object();
for (var [key, value] of distinctNodes){
  collapse.name = key;
}


function tick() {
  link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

}


function mouseover() {
  d3.select(this).select("circle").transition()
      .duration(750)
      .attr("r", 20)
      .attr("fill", "red");

}

function mouseout() {
  d3.select(this).select("circle").transition()
      .duration(750)
      .attr("r", 8)
      .attr("fill", "silver");
  

}





        </script>
    </body>
</html>