<!DOCTYPE html>

<meta charset="utf-8">
<style>

.node {
  stroke: #bbb;
  stroke-width: 0.5px;
}

.link {
  stroke: #999;
  stroke-opacity:0.5;
  stroke-width: 1.5px;
}


circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}


</style>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>D3 Test</title>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src = "tester.js"></script>
    </head>
    <body>
    <script>


// initializes the objects 

// the links represent each of clip submission (comparison)logically we represent those as links

var links = b.cameras;

// We used a map to strip down the data to just the distinct nodes that appear. When it comes to the display, we don't want to produce multiple nodes for each camera.

// clips refer to a data point in the tester.js file. Every clip refers to a comparison (two products and how they fair: source and target)

function createMap() {
  connectionMap = new Map()
  for (var i = 0; i < links.length; i++){
  var clip = links[i];
  //goes through all of the clips and adds every new unique camera to 
  if (!(connectionMap.has(clip["target"]))){
    var firstSource = new Set();
    connectionMap.set(clip["target"], firstSource.add(clip["source"]));
    }else{
      //if the product is already in the set then we still have to add the source to the list of things its compared to. multiples are taken care of with the set.
      var updatedValues = connectionMap.get(clip["target"]);
      updatedValues.add(clip["source"]);
      connectionMap.set(connectionMap["target"], updatedValues);
 }
  if (!(connectionMap.has(clip["source"]))){
  var firstTarget = new Set();
  connectionMap.set(clip["source"], firstTarget.add(clip["target"]));
  }else{  
    var updatedValues = connectionMap.get(clip["source"]);
      updatedValues.add(clip["target"]);
      connectionMap.set(connectionMap["source"], updatedValues);

  
 }
  
}
return connectionMap
}

var distinctNodes = createMap()
console.log(distinctNodes)


// labels all of the nodes
var extra = [];
for (var [key, value] of distinctNodes){
  if(value.size == 1){
    extra.push(key);
  }
}
 

extra.forEach(function(camera){
  links.forEach(function(camFacts){
    if (camera == camFacts["target"] || camera == camFacts["source"]){
        camFacts.type = "S";
    }
  })
})

links.forEach(function(camFacts){
  if (camFacts.type != "S"){
    camFacts.type = "NS";
  }
  

})


var links2 = links.slice();
var collapse = new Object();
for (var [key, value] of distinctNodes){
  collapse.name = key;
}

console.log(collapse);

function isInArray(value, array) {
  return array.indexOf(value) > -1;
}


var nodes = {};

// Compute the distinct nodes from the links.
  links.forEach(function(link) {
  link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
  link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
});

 
var width = 960,
    height = 500;

var force = d3.layout.force()
    .nodes(d3.values(nodes))
    .links(links)
    .size([width, height])
    .linkDistance(100)
    .charge(-300)
    .on("tick", tick)
    .start();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var link = svg.selectAll(".link")
    .data(force.links())
    .enter().append("line")
    .attr("class", "link");

var node = svg.selectAll(".node")
    .data(force.nodes())
    .enter().append("g")
    .attr("class", "node")
    .on("mouseover", mouseover)
    .on("mouseout", mouseout)
    .call(force.drag);

node.append("circle")
    .attr("r", 8);

node.append("text")
    .attr("x", 12)
    .attr("dy", ".35em")
    .text(function(d) { return d.name;});


function tick() {
  link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
}

function mouseover() {
  d3.select(this).select("circle").transition()
      .duration(750)
      .attr("r", 20)
      .attr("fill", "red");

}

function mouseout() {
  d3.select(this).select("circle").transition()
      .duration(750)
      .attr("r", 8)
      .attr("fill", "silver");
  

}





        </script>
    </body>
</html>